# fandango-learn

This repository contains the code for the Fandango Learn project.
The goal is to automatically learn _fandango_ constraints form a set of inputs.

Overall, the learner will be integrated into **Avicenna**, which provides the necessary infrastructure of the hypothesis refinement loop.
Furthermore, **Avicenna** provides the means to automatically learn the set of relevant non-terminals, reducing the search space for the learner.

## Quick Start (Prototype)

### Introduction to FandangoLearner

This notebook demonstrates how to use **FandangoLearner**, a pattern based approach that automatically learns constraints to explain why a program fails.

The core idea of FandangoLearner is to identify patterns in inputs 
that lead to program errors or unexpected behaviors. Using these patterns, 
it generates constraints in the Fandango language to help developers 
understand input-related bugs.

### Step 1: Define the Grammar
We start by defining the grammar for our input language.
This example focuses on arithmetic expressions using trigonometric and square root functions.

```python
from fandango.language.parse import parse

grammar = """
<start> ::= <arithexp>;
<arithexp> ::= <function>"("<number>")";
<function> ::= "sqrt" | "cos" | "sin" | "tan";
<number> ::= <maybeminus><onenine><maybedigits> | "0";
<maybeminus> ::= "-" | "";
<onenine> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
<maybedigits> ::= <digit>*;
<digit>::=  "0" | <onenine>;
"""

grammar, _ = parse(grammar)
```

### Step 2: Provide Initial Inputs

We supply a set of example inputs along with their expected outcomes (`True` for failure, `False` otherwise).

```python
initial_inputs = {
    ("sqrt(-900)", True),  # This input causes a failure.
    ("sqrt(-10)", True),   # Another failure case.
    ("sqrt(0)", False),    # This input works correctly.
    ("sin(-900)", False),  # Works correctly.
    ("sqrt(2)", False),    # Works correctly.
    ("cos(10)", False),    # Works correctly.
}
```

Convert inputs to FandangoInput objects

```python
from fandangoLearner.learner import FandangoInput

initial_inputs = {
  FandangoInput.from_str(grammar, inp, oracle)
  for inp, oracle in initial_inputs
}
```

### Step 3: Select Relevant Non-Terminals (Optional)

We specify the non-terminals in the grammar that are likely related to the program's failure behavior.
This step is optional but can help focus the learning process on specific parts of the grammar.
Later, we will see that **Avicenna** can automatically learn relevant non-terminals. 

```python
from fandangoLearner.learner import NonTerminal

relevant_non_terminals = {
    NonTerminal("<number>"),
    NonTerminal("<maybeminus>"),
    NonTerminal("<function>"),
}
```

## Step 4: Learn Constraints

Using the `FandangoLearner`, we learn constraints that explain why certain inputs fail.

```python
from fandangoLearner.learner import FandangoLearner

learner = FandangoLearner(grammar)

learned_constraints = learner.learn_constraints(
    initial_inputs,
    relevant_non_terminals=relevant_non_terminals
)
```

## Step 5: Analyze Results

Finally, we analyze the constraints generated by FandangoLearner to understand the root cause of failures.

```python
print("Learned Constraints:")
for constraint in learner.get_best_candidates():
    print(constraint)
```

The output will show the constraints that best explain the failures in the initial inputs.

```plaintext
(str(<function>) == 'sqrt' and int(<number>) <= -10), 
Precision: 1.0, Recall: 1.0 (based on 2 failing and 4 passing inputs)
```

We can see that the constraint `(str(<function>) == 'sqrt' and int(<number>) <= -10)` explains why the inputs `sqrt(-900)` and `sqrt(-10)` fail.
However, this constraint is too specific and does not generalize well to other inputs.
Thus, we need a feedback loop that automatically refines these constraints to generate general constraints that captures the essence of the failure.
We will use **Avicenna** to provide this feedback loop.

## First Ideas

- Use Pattern Based Approach
   - Will likely lead to combinatorial explosion
   - Requires similar ideas as scatched in the Avicenna paper, i.e. reduce the number of relevant non-terminals
- Build atomic constraints
   - Use the atomic constraints to build more complex constraints
   - Atomic constraints will be combined to more complex constraints with conjunctions and disjunctions.
- Implement different filter mechanisms 
   - Allow to rank constraints based on different criteria like precision, recall, etc.

new idea:
- exists and forall constraints can be quite similar to each other, when that use bounded nonterminals that are applied only once.
   - we might want to use forall constraints only when they are really needed, i.e. when the nonterminal is used multiple times.


## Reusability

The code should be reusable for other projects, such as Avicenna.
Therefore, the code uses many abstract classes that are already implemented in Avicenna and AvicennaISLearn.
This makes comparing both approaches FandangoLearn and ISLearn extremely easy.

## Usage

Work in progress. The following code snippet shows how to use the FandangoStringPatternLearner to learn atomic constraints from a set of inputs.
See the `playground` folder for the [working prototype](./playground/readme.py).

```python
from fandangoLearner.learner import FandangoLearner
from fandango.language.parse import parse_file
from fandangoLearner.data.input import FandangoInput, OracleResult

grammar, _ = parse_file("calculator.fan")
test_inputs = [
    ("sqrt(-900)", OracleResult.FAILING),
    ("sqrt(-1)", OracleResult.FAILING),
    ("sin(-900)", OracleResult.PASSING),
    ("sqrt(2)", OracleResult.PASSING),
    ("cos(10)", OracleResult.PASSING),
]

initial_inputs = {
    FandangoInput.from_str(grammar, inp, result) for inp, result in test_inputs
}

patterns = [
    "int(<NON_TERMINAL>) <= <INTEGER>;",
    "int(<NON_TERMINAL>) == <INTEGER>;",
    "str(<NON_TERMINAL>) == <STRING>;",
    "int(<NON_TERMINAL>) == len(str(<NON_TERMINAL>));",
    "int(<NON_TERMINAL>) == int(<NON_TERMINAL>) * <INTEGER> * int(<NON_TERMINAL>) * <INTEGER>;",
]

non_terminal_values = {
    NonTerminal("<number>"),
    NonTerminal("<maybeminus>"),
    NonTerminal("<function>"),
}

learner = FandangoLearner(grammar, patterns)
learned_constraints = learner.learn_constraints(initial_inputs, non_terminal_values)

for candidate in learned_constraints:
    candidate.evaluate(initial_inputs)
    print(
        f"Constraint: {candidate.constraint}, Recall: {candidate.recall()}, Precision: {candidate.precision()}"
    )
```

Produces the following constraints:

```
Constraint: (str(<function>) == 'sqrt' and str(<maybeminus>) == '-'), Recall: 1.0, Precision: 1.0
Constraint: (str(<function>) == 'sqrt' and int(<number>) <= -1), Recall: 1.0, Precision: 1.0
```


## Old Steps (Already Implemented) 

Next steps: Automatically combining constraints to more complex constraints:

```python
cand1 = filtered_candidates[-1]
cand2 = filtered_candidates[-2]
cand3 = cand1 & cand2
cand3.evaluate(initial_inputs)
print("Combined Constraints:")
print("Constraint:", cand3.constraint, "Recall:", cand3.recall(), "Precision:", cand3.precision())
```

Produces the following combined constraint:

```
Combined Constraints:
Constraint: (str(<function>) == 'sqrt' and str(<maybeminus>) == '-') Recall: 1.0 Precision: 1.0
```

